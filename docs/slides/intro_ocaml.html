<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2020-01-09 Thu 13:02 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Introduction to OCaml</title>
<meta name="generator" content="Org mode" />
<meta name="author" content="Richard B." />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { width: 90%; }
  /*]]>*/-->
</style>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/htmlize.css"/>
<link rel="stylesheet" type="text/css" href="https://fniessen.github.io/org-html-themes/styles/readtheorg/css/readtheorg.css"/>
<script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/lib/js/jquery.stickytableheaders.min.js"></script>
<script type="text/javascript" src="https://fniessen.github.io/org-html-themes/styles/readtheorg/js/readtheorg.js"></script>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2019 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="content">
<h1 class="title">Introduction to OCaml</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgf0495d7">1. Disclaimer</a></li>
<li><a href="#orga1cfc05">2. Introduction</a>
<ul>
<li><a href="#org4224f51">2.1. The <b>Categorical Abstract Machine Language</b></a></li>
<li><a href="#org9c205fa">2.2. OCaml : an open-minded(?) functional language</a>
<ul>
<li><a href="#org39eee6a">2.2.1. Standard library</a></li>
</ul>
</li>
<li><a href="#orgd13ccbb">2.3. Bytecode and native code support</a></li>
<li><a href="#orgf31d2a0">2.4. Users</a>
<ul>
<li><a href="#orgd79dff3">2.4.1. Usual domains</a></li>
</ul>
</li>
<li><a href="#orga8f5a0e">2.5. Tooling (as of )</a></li>
</ul>
</li>
<li><a href="#orgf5e0b36">3. Syntax Basics?</a>
<ul>
<li><a href="#orgc5b54cc">3.1. let-bindings</a></li>
<li><a href="#orgffeea3f">3.2. Functions</a></li>
<li><a href="#org3eb3b01">3.3. Recursivity</a></li>
<li><a href="#org5017421">3.4. Functions are first-class citizens</a></li>
<li><a href="#org5ac9d51">3.5. Evaluation is strict</a>
<ul>
<li><a href="#org13ccaf6">3.5.1. Oddity</a></li>
</ul>
</li>
<li><a href="#org22bcf01">3.6. Grouping information : Tuples</a></li>
<li><a href="#org3afe6ff">3.7. Everything is a pattern</a></li>
<li><a href="#orgc338089">3.8. Grouping information : Records (aka named tuples)</a></li>
<li><a href="#orgabdd81b">3.9. ADT &amp; pattern matching</a></li>
<li><a href="#org28d09e2">3.10. Labels (aka named arguments)</a></li>
<li><a href="#org94217a5">3.11. Optional arguments</a></li>
<li><a href="#org1223c87">3.12. Optional arguments <b>are</b> option types</a></li>
<li><a href="#orgbb91464">3.13. Using named arguments in practice</a></li>
<li><a href="#org9a1ea0e">3.14. Nice to have: type-directed record disambiguation</a></li>
</ul>
</li>
<li><a href="#orgcd3387c">4. Imperative programming</a>
<ul>
<li><a href="#orgd8fcf52">4.1. It's ok to be impure</a></li>
<li><a href="#org7d553d3">4.2. The unit type</a></li>
<li><a href="#orga98995d">4.3. Trivia :: What's in a reference?</a></li>
<li><a href="#org4eaddd8">4.4. Typical OCaml code</a></li>
<li><a href="#org1356d5b">4.5. Trivia :: Hashtables</a></li>
<li><a href="#org32bda16">4.6. Pitfall(s)</a></li>
<li><a href="#org0bd10db">4.7. Exceptions</a></li>
<li><a href="#org8c5bc0c">4.8. Local exceptions &amp; pattern-matching mixed exceptions/values</a></li>
</ul>
</li>
<li><a href="#orgae57063">5. More advanced topics</a>
<ul>
<li><a href="#org78a746e">5.1. What's a module?</a></li>
<li><a href="#org7808c32">5.2. Interface &amp; implementation :: <code>mli</code> &amp; <code>ml</code></a>
<ul>
<li><a href="#org3d60083">5.2.1. Simple Functional Stacks</a></li>
</ul>
</li>
<li><a href="#orgf2f1401">5.3. Levels of type abstraction</a>
<ul>
<li><a href="#org45fe44f">5.3.1. Open</a></li>
<li><a href="#org80f25b4">5.3.2. Private</a></li>
<li><a href="#orgbae19ce">5.3.3. Abstract</a></li>
</ul>
</li>
<li><a href="#org382dc81">5.4. Genericity</a>
<ul>
<li><a href="#org94d83e7">5.4.1. Ad-hoc polymorphism</a></li>
<li><a href="#orgcdabd2a">5.4.2. Functors (module generator)</a></li>
</ul>
</li>
<li><a href="#orga4023ab">5.5. First-order modules</a>
<ul>
<li><a href="#org9eb8da7">5.5.1. More involved example</a></li>
</ul>
</li>
<li><a href="#orgf3b675a">5.6. Monadic style programming</a></li>
<li><a href="#org9e0b911">5.7. GADTs</a></li>
<li><a href="#orgd2ac5bb">5.8. Death by GADTs</a></li>
<li><a href="#orgb082d27">5.9. <code>Format</code>'ing text</a></li>
<li><a href="#org1b703cf">5.10. Things that I did not talk about</a></li>
</ul>
</li>
<li><a href="#orgcca08a1">6. Conclusion</a></li>
</ul>
</div>
</div>

<div id="outline-container-orgf0495d7" class="outline-2">
<h2 id="orgf0495d7"><span class="section-number-2">1</span> Disclaimer</h2>
<div class="outline-text-2" id="text-1">
<p>
This intro is incomplete ;-)
</p>
</div>
</div>

<div id="outline-container-orga1cfc05" class="outline-2">
<h2 id="orga1cfc05"><span class="section-number-2">2</span> Introduction</h2>
<div class="outline-text-2" id="text-2">
</div>
<div id="outline-container-org4224f51" class="outline-3">
<h3 id="org4224f51"><span class="section-number-3">2.1</span> The <b>Categorical Abstract Machine Language</b></h3>
<div class="outline-text-3" id="text-2-1">
<p>
OCaml is part of the ML family, like SML (big brother) or F# (little brother).
</p>

<dl class="org-dl">
<dt>1973</dt><dd><p>
(Classical) ML
</p>

<p>
Check the foundations from <a href="http://www.nuprl.org/software/eventml/KreitzandRahli-ClassicML.pdf">here</a>.
</p></dd>
<dt>1987-1992</dt><dd>Heavy CAML (LISP-based implementation)</dd>
<dt>1990-1991</dt><dd>Caml Light</dd>
<dt>1996</dt><dd>Objective Caml 1.00</dd>
<dt>2011</dt><dd>Rebranding to OCaml (not O'Caml, not oCaml, <code>Just OCaml</code>)</dd>
<dt>2019</dt><dd>OCaml 4.09</dd>
</dl>
</div>
</div>

<div id="outline-container-org9c205fa" class="outline-3">
<h3 id="org9c205fa"><span class="section-number-3">2.2</span> OCaml : an open-minded(?) functional language</h3>
<div class="outline-text-3" id="text-2-2">
<p>
It is <b>not</b> a purely functional language: imperative programming is part of
the nominal toolbox, even OOP when it is the right fit.
</p>
</div>


<div id="outline-container-org39eee6a" class="outline-4">
<h4 id="org39eee6a"><span class="section-number-4">2.2.1</span> Standard library</h4>
<div class="outline-text-4" id="text-2-2-1">
<p>
The standard lib has been kept voluntarily small.
</p>

<p>
There have been various efforts to provide "batteries".
</p>
</div>
</div>
</div>


<div id="outline-container-orgd13ccbb" class="outline-3">
<h3 id="orgd13ccbb"><span class="section-number-3">2.3</span> Bytecode and native code support</h3>
<div class="outline-text-3" id="text-2-3">
<p>
2 compilers for the price of one:
</p>
<ol class="org-ol">
<li>a bytecode compiler (<code>ocamlc</code>) to a stack-based VM, and its interpreter <code>ocamlrun</code>
works anywhere you have a C compiler</li>
<li>a native code compiler (<code>ocamlopt</code>)
<ul class="org-ul">
<li>supports x86 (32/64), ARM (v5-v8), PowerPC(32/64) and &#x2026; SPARC !</li>
<li>RISC-V not yet integrated but support exists</li>
</ul></li>
</ol>
</div>
</div>

<div id="outline-container-orgf31d2a0" class="outline-3">
<h3 id="orgf31d2a0"><span class="section-number-3">2.4</span> Users</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>(Mostly French) academic circles
<dl class="org-dl">
<dt>academia</dt><dd>INRIA, CEA, CMU, UPenn, Berkeley, UArizona</dd>
<dt>SMEs</dt><dd>OCamlPro/Origin Labs, Nomadic Labs, TrustInSoft, Tarides,</dd>
</dl></li>
<li>Financial "institutions" &#x2013; Jane Street, Bloomberg, SimCorp, Lexifi</li>
<li>Facebook (ReasonML, Infer)</li>
<li>Atos, AbsInt</li>
<li>Indirectly Airbus (Astrée, Frama-C, Fluctuat), EDF</li>
</ul>
</div>


<div id="outline-container-orgd79dff3" class="outline-4">
<h4 id="orgd79dff3"><span class="section-number-4">2.4.1</span> Usual domains</h4>
<div class="outline-text-4" id="text-2-4-1">
<ul class="org-ul">
<li>compilers</li>
<li>program analysis</li>
<li>theorem proving</li>
<li>symbolic computations</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orga8f5a0e" class="outline-3">
<h3 id="orga8f5a0e"><span class="section-number-3">2.5</span> Tooling (as of )</h3>
<div class="outline-text-3" id="text-2-5">
<dl class="org-dl">
<dt>the <a href="https://github.com/ocaml/ocaml">compiler</a></dt><dd>last release is 4.09 (2019-09-18)</dd>
<dt><a href="https://github.com/ocaml/merlin">merlin</a></dt><dd><p>
context-sensitive completion for OCaml (in Vim &amp; Emacs)
</p>

<p>
A <b>very</b> nice tool which has changed the life of most OCaml developers,
and it's editor-agnostic !
</p></dd>
<dt><a href="https://github.com/ocaml/dune">dune</a></dt><dd><p>
the newest contender in dedicated build systems
</p>

<p>
May OCamlMakefile, omake, ocamlbuild rest in peace.
</p></dd>

<dt><a href="https://github.com/ocaml/opam">OPAM</a> (v1.0 in 2013)</dt><dd><p>
current is 2.5 (2019-07-11)
</p>

<p>
A source-based package manager for OCaml software.
</p></dd>
<dt>(no term)</dt><dd>Emacs</dd>
</dl>


<p>
Check out
</p>
<ul class="org-ul">
<li><a href="https://opam.ocaml.org/blog/turn-your-editor-into-an-ocaml-ide/">https://opam.ocaml.org/blog/turn-your-editor-into-an-ocaml-ide/</a></li>
</ul>
</div>
</div>
</div>



<div id="outline-container-orgf5e0b36" class="outline-2">
<h2 id="orgf5e0b36"><span class="section-number-2">3</span> Syntax Basics?</h2>
<div class="outline-text-2" id="text-3">
</div>
<div id="outline-container-orgc5b54cc" class="outline-3">
<h3 id="orgc5b54cc"><span class="section-number-3">3.1</span> let-bindings</h3>
<div class="outline-text-3" id="text-3-1">
<div class="org-src-container">
<pre class="src src-ocaml">let x = Pervasives.read_int () in
let y = Pervasives.read_int () in
Pervasives.print_int (x + y);
Pervasives.print_newline ()
;;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgffeea3f" class="outline-3">
<h3 id="orgffeea3f"><span class="section-number-3">3.2</span> Functions</h3>
<div class="outline-text-3" id="text-3-2">
<div class="org-src-container">
<pre class="src src-ocaml">let add x y =
  x + y
;;
</pre>
</div>

<p>
Since we are in a so-called functional languages, let's talk about functions.
</p>

<p>
Functions are <b>curried</b> (unlike SML functions).
</p>

<p>
That means <code>add x y</code> actually is <code>add(x)(y)</code> and <code>add</code> can be partially
applied (or <code>add x</code>).
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let add1 = add 1 ;;

add1 2 ;;
</pre>
</div>
</div>
</div>


<div id="outline-container-org3eb3b01" class="outline-3">
<h3 id="org3eb3b01"><span class="section-number-3">3.3</span> Recursivity</h3>
<div class="outline-text-3" id="text-3-3">
<p>
Recursive functions are explicitly qualified by the <b>rec</b> keyword.
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let rec fact n =
  if n &lt; 2 then 1 else n * fact (n - 1)
;;

let rec foldl f acc = function
  | [] -&gt; acc
  | x :: xs -&gt; foldl f (f acc x) xs
;;

foldl (+) 0 [1;2;3;4] ;; (* 10 \o/ *)
</pre>
</div>

<p>
Functions are not recursive by default.
</p>

<div class="org-src-container">
<pre class="src src-ocaml">(* This second declaration hides the first.*)
let fact n = assert (n &gt;= 0); fact n
</pre>
</div>
</div>
</div>



<div id="outline-container-org5017421" class="outline-3">
<h3 id="org5017421"><span class="section-number-3">3.4</span> Functions are first-class citizens</h3>
<div class="outline-text-3" id="text-3-4">
<div class="org-src-container">
<pre class="src src-ocaml">(* [max cmp l] computes the maximun element of a list [l] provided a [cmp]
 * function which is expected to conform to the following specification:
 * - cmp x y = 0 if x is equivalent to y
 * - cmp x y &gt; 0 if x is bigger than y
 * - cmp x y &lt; 0 if x if smaller than y
 *)
let max cmp l =
  let rec aux cur_max l =
    match l with
    | [] -&gt; cur_max
    | x :: xs -&gt;
       let cur_max' =
	 match cur_max with
	 | None -&gt; Some x
	 | Some vmax -&gt; if cmp x vmax &gt; 0 then Some x else cur_max in
       aux cur_max' xs
  in aux None l
;;

max Pervasives.compare [1; 2; 3;] ;;

(* Oopsie, we just rewrote the [Pervasives.max] function !*)
Pervasives.max ;;
</pre>
</div>
</div>
</div>

<div id="outline-container-org5ac9d51" class="outline-3">
<h3 id="org5ac9d51"><span class="section-number-3">3.5</span> Evaluation is strict</h3>
<div class="outline-text-3" id="text-3-5">
<p>
Like in most programming languages ;-)
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let double x = 2 * x ;;

let dadd x y =
  let x' = double x
  and y' = double y in
  ( + ) x' y'
  (* Infix operators are prefixed ones that are treated specially by the parser.
     Have fun and create your owns. *)
 ;;

dadd (double 1) (double 2) ;;
</pre>
</div>

<p>
&#x2026; well except for binary Boolean operators &#x2013; of course ;-).
</p>
</div>

<div id="outline-container-org13ccaf6" class="outline-4">
<h4 id="org13ccaf6"><span class="section-number-4">3.5.1</span> Oddity</h4>
<div class="outline-text-4" id="text-3-5-1">
<p>
Evaluation order for function arguments is <b>unspecified</b>.
</p>

<p>
It is usually right-to-left, though.
</p>

<p>
You can check it out with the following dummy example 
</p>
<div class="org-src-container">
<pre class="src src-ocaml">let x () = print_string "foo" in
let y () = print_string "bar" in
let f x y = () in
f (x ()) (y ())
;;
</pre>
</div>

<p>
If it prints <code>"barfoo"</code> the evaluation order is indeed right-to-left.
</p>
</div>
</div>
</div>

<div id="outline-container-org22bcf01" class="outline-3">
<h3 id="org22bcf01"><span class="section-number-3">3.6</span> Grouping information : Tuples</h3>
<div class="outline-text-3" id="text-3-6">
<div class="org-src-container">
<pre class="src src-ocaml">let a = 1, 2 in
let x, y = a in
x + y
;;
</pre>
</div>

<p>
can also be written with <code>( .. )</code> as
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let a = (1, 2) in
let (x, y) = a in
x + y
;;
</pre>
</div>
</div>
</div>



<div id="outline-container-org3afe6ff" class="outline-3">
<h3 id="org3afe6ff"><span class="section-number-3">3.7</span> Everything is a pattern</h3>
<div class="outline-text-3" id="text-3-7">
<div class="org-src-container">
<pre class="src src-ocaml">type point_3d = float * float * float

let create x y z = x, y, z ;;

(* Yes, FP arithmetic operations have a dedicated syntax *)
let square a = a *. a ;;

let dist (x1, y1, z1) p =
  let x2, y2, z2 = p in
  let xdiff = x2 -. x1
  and ydiff = y2 -. y1
  and zdiff = z2 -. z1 in
  square xdiff +. square ydiff +. square zdiff
  |&gt; sqrt
;;

let dist p1 p2 =
  match p1, p2 with
  (* The | can also be used as a separator instead of as a starting
     annotation. *)
  | (x1, y1, z1), (x2, y2, z2) -&gt;
     let xdiff = x2 -. x1
     and ydiff = y2 -. y1
     and zdiff = z2 -. z1 in
     sqrt (square xdiff +. square ydiff +. square zdiff)
;;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgc338089" class="outline-3">
<h3 id="orgc338089"><span class="section-number-3">3.8</span> Grouping information : Records (aka named tuples)</h3>
<div class="outline-text-3" id="text-3-8">
<div class="org-src-container">
<pre class="src src-ocaml">type point_2d = { x : float; y: float; }  ;;

(* C-like . notations for field access *)
let dist p1 p2 =
  let xdiff = p1.x -. p2.x
  and ydiff = p1.y -. p2.y in
  sqrt (xdiff *. xdiff +. ydiff *. ydiff)
;;

(* Using pattern-matching *)
let dist2 p1 p2 =
  match p1, p2 with
  | { x; y; }, { x = x'; y = y';} -&gt;
     let xdiff = x -. x'
     and ydiff = y -. y' in
     sqrt (xdiff *. xdiff +. ydiff *. ydiff)
;;

(* Record can be built/destructed using a shortcut notation.
   [let create x y = { x; y; }] is a shortcut for
   [let create x y = { x = x; y = y; }].

   Choose your field names wisely and unleash your inner procrastinator !
 *)
let create x y = { x; y; } ;;

let of_int myx myy = { x = float myx; y = float myy; } ;;
</pre>
</div>


<blockquote>
<p>
Records are limited to 2<sup>22</sup> − 1 fields 
</p>
</blockquote>
</div>
</div>


<div id="outline-container-orgabdd81b" class="outline-3">
<h3 id="orgabdd81b"><span class="section-number-3">3.9</span> ADT &amp; pattern matching</h3>
<div class="outline-text-3" id="text-3-9">
<p>
Exhaustive and fragile pattern matching are reported by default.
</p>

<div class="org-src-container">
<pre class="src src-ocaml">type prop =
  | Cst of bool
  | Var of string
  | Band of prop * prop
  | Bor of prop * prop
  | Bnot of prop
;;

let free_variables =
(* The pattern matching here is well-typeg but not exhaustive *)
  let rec loop vars =
    | Var s -&gt; if List.mem s vars then vars else s :: vars
    | Band (p1, p2) -&gt;
       let vars' = loop vars p1 in
       loop vars' p2
  in loop []
;;

let free_variables =
  (* Now it is exhaustive, but ... fragile *)
  let rec loop vars =
    | Var s -&gt; if List.mem s vars then vars else s :: vars
    | Band (p1, p2) -&gt;
       let vars' = loop vars p1 in
       loop vars' p2
    | Bor (p1, p2) -&gt;
       let vars' = loop vars p1 in
       loop vars' p2
    | Bnot p -&gt; loop vars p
    | _ -&gt; vars (* fragile pattern-matching if a constructor is added, it is
		   matched here *)
  in loop []
;;
</pre>
</div>

<p>
The compact solution for this function includes or-patterns.
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let free_variables =
  let rec loop vars = function
    | Var s -&gt; if List.mem s vars then vars else s :: vars
    | Band (p1, p2)
    | Bor (p1, p2) -&gt; (* 'or' pattern *)
       let vars' = loop vars p1 in
       loop vars' p2
    | Bnot p -&gt; loop vars p
    | Cst _ -&gt; vars (* non-fragile pattern-matching *)
    (* When I later add the [Bxor] constructor, the
     * compiler will show me where pattern-matching is not exhaustive.
     *)
  in loop []
;;
</pre>
</div>


<p>
For (way) more:
</p>
<ul class="org-ul">
<li><a href="https://dl.acm.org/doi/10.1145/507669.507641">https://dl.acm.org/doi/10.1145/507669.507641</a></li>
</ul>
</div>
</div>

<div id="outline-container-org28d09e2" class="outline-3">
<h3 id="org28d09e2"><span class="section-number-3">3.10</span> Labels (aka named arguments)</h3>
<div class="outline-text-3" id="text-3-10">
<p>
Named arguments are mainly used for 2 reasons:
</p>
<ul class="org-ul">
<li><p>
name-based disambiguation of same type parameters
</p>

<div class="org-src-container">
<pre class="src src-ocaml">type interval = { lo : int; hi : int } ;;
let create ~lo ~hi = { lo; hi; }
</pre>
</div></li>

<li><p>
homogeneous naming betting on programmers' procrastination
</p>

<div class="org-src-container">
<pre class="src src-ocaml">(* Which version would you rather write? *)

let lo = 12 and hi = 15 in create ~lo ~hi  ;;

let lbd = 12 and ubd = 15 in create ~lo:lbd ~hi:ubd ;;
</pre>
</div></li>
</ul>
</div>
</div>





<div id="outline-container-org94217a5" class="outline-3">
<h3 id="org94217a5"><span class="section-number-3">3.11</span> Optional arguments</h3>
<div class="outline-text-3" id="text-3-11">
<p>
A special case of named arguments is optional arguments
</p>

<div class="org-src-container">
<pre class="src src-ocaml">type interval = { lo : int; hi : int } ;;

let create ?(lo=0) hi = { lo; hi; } ;;

create 2;;


let create ?(lo=0) ~hi () = { lo; hi; } ;;

let ival = create ~hi:2 ();;


(* The use of partial arguments complicate a little bit closure computations.*)
let pp_ival ?(pre="(") ?(post=")") ?(sep=",")ppf { lo; hi; } =
  Format.fprintf ppf "@[&lt;h&gt;%s%d%s%d%s@]" pre lo sep hi post
;;

(* The following does not type *)
Format.printf "%a@." pp_ival ival ;;

(* You need to create another function *)
Format.printf "%a@." (fun ppf ival -&gt; pp_ival ppf ival) ival ;;

(* The following does work though *)
let pp_ival2 ppf = pp_ival ppf ;;
Format.printf "%a@." pp_ival2 ival ;;
</pre>
</div>
</div>
</div>


<div id="outline-container-org1223c87" class="outline-3">
<h3 id="org1223c87"><span class="section-number-3">3.12</span> Optional arguments <b>are</b> option types</h3>
<div class="outline-text-3" id="text-3-12">
<div class="org-src-container">
<pre class="src src-ocaml">type ('a, 'b) return = {
    value : 'a;
    explanation : 'b option;
  }
;;

(* Optional arguments of a type ['a] are really ['a option] types and ce be
 * used that way in the body of the function *)
let create_return_value ?explanation value =
  { value; explanation; }
;;

(* Now if you have a default value [v], [Some v] needs to be used. *)
let create_defaulted_return_value ?(explanation="message") value =
  { value; explanation = Some explanation; }
;;

(* The construction below does not type. *)
let create_defaulted_return_value ?(explanation="message") value =
  { value; explanation; }
;;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgbb91464" class="outline-3">
<h3 id="orgbb91464"><span class="section-number-3">3.13</span> Using named arguments in practice</h3>
<div class="outline-text-3" id="text-3-13">
<p>
A commonly used recipe to construct functions with named arguments is:
</p>
<ol class="org-ol">
<li>Put your optional arguments</li>
<li>Put your named arguments</li>
<li>Put the rest of your arguments</li>
</ol>
</div>
</div>

<div id="outline-container-org9a1ea0e" class="outline-3">
<h3 id="org9a1ea0e"><span class="section-number-3">3.14</span> Nice to have: type-directed record disambiguation</h3>
<div class="outline-text-3" id="text-3-14">
<div class="org-src-container">
<pre class="src src-ocaml">type t = { x : float; y : int; } ;;

(* Shadowing x and y *)
type t' = { x : int; y : float; } ;;


let addall (v1:t) v2 =
  let xsum = truncate v1.x + v2.x in
  let ysum = v1.y + truncate v2.y in
  xsum + ysum
;;
</pre>
</div>

<p>
Check out:
</p>
<ol class="org-ol">
<li><a href="http://gallium.inria.fr/~scherer/gagallium/resolving-field-names/">http://gallium.inria.fr/~scherer/gagallium/resolving-field-names/</a></li>
<li><a href="http://gallium.inria.fr/~scherer/gagallium/resolving-field-names-2/">http://gallium.inria.fr/~scherer/gagallium/resolving-field-names-2/</a></li>
</ol>
</div>
</div>
</div>



<div id="outline-container-orgcd3387c" class="outline-2">
<h2 id="orgcd3387c"><span class="section-number-2">4</span> Imperative programming</h2>
<div class="outline-text-2" id="text-4">
</div>
<div id="outline-container-orgd8fcf52" class="outline-3">
<h3 id="orgd8fcf52"><span class="section-number-3">4.1</span> It's ok to be impure</h3>
<div class="outline-text-3" id="text-4-1">
<p>
A bunch of OCaml primitive constructs are imperative.
</p>

<ul class="org-ul">
<li>ref</li>
<li>mutable field in records</li>
<li>arrays</li>
<li>hashtables</li>
<li>bytes (aka strings before 4.02)</li>
<li>stacks, queues, &#x2026;.</li>
</ul>

<p>
No need to read Okasaki's book to understand their implementation ;-)
</p>
</div>
</div>


<div id="outline-container-org7d553d3" class="outline-3">
<h3 id="org7d553d3"><span class="section-number-3">4.2</span> The unit type</h3>
<div class="outline-text-3" id="text-4-2">
<p>
The type of sequence elements (think 'statement') is <code>unit</code>, which is
inhabited by a single value <code>()</code>.
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let fact n =
  let res = ref 1 in
  for j = 2 to n do
    res := !res * j; (* this assignment has type unit *)
  done;
  !res
;;
</pre>
</div>
</div>
</div>

<div id="outline-container-orga98995d" class="outline-3">
<h3 id="orga98995d"><span class="section-number-3">4.3</span> Trivia :: What's in a reference?</h3>
<div class="outline-text-3" id="text-4-3">
<div class="org-src-container">
<pre class="src src-ocaml">let x = ref 1 ;;

let y = { contents = 12 } ;;

type 'a ref = { mutable contents : 'a };;
</pre>
</div>
</div>
</div>

<div id="outline-container-org4eaddd8" class="outline-3">
<h3 id="org4eaddd8"><span class="section-number-3">4.4</span> Typical OCaml code</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Typical code mixes and matches functional and imperative features, usually
for efficiency reasons. You will not be castigated for doing so.
</p>

<div class="org-src-container">
<pre class="src src-ocaml">(* Assuming I use a list-based representation for sets, it is very idiomatic
 * way to write the code below *)
let cardinal l =
  let h = Hashtbl.create 7 in
  let rec loop = function
    | x :: xs -&gt;
       Hashtbl.add h x (); (* Hashtbl.replace may be better here *)
       loop xs
    | [] -&gt;
       Hashtbl.length h
  in loop l
;;
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml">(* Concatenating the elements of a string list *)
let concat =
  (* An OCaml [Buffer.t] is similar to a Java [StringBuffer].
   * It is a self-growing array bytes.
   *)
  let b = Buffer.create 1024 in
  fun ~sep l -&gt;
  Buffer.reset b;    (* cleanup any previously written contents *)
  List.iter
  (fun s -&gt; Buffer.add_string b s;
	    Buffer.add_string b sep;)
  l;
  Buffer.contents b
;;
</pre>
</div>
</div>
</div>


<div id="outline-container-org1356d5b" class="outline-3">
<h3 id="org1356d5b"><span class="section-number-3">4.5</span> Trivia :: Hashtables</h3>
<div class="outline-text-3" id="text-4-5">
<p>
Hashtables have an interesting property : <code>add</code> does not remove old values!
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let h = Hashtbl.create 7 ;;
Hashtbl.add h 1 2 ;;
Hashtbl.add h 1 3 ;;
Hashtbl.iter (fun k v -&gt; Format.printf "%d -&gt; %d@." k v) h ;;
</pre>
</div>
</div>
</div>

<div id="outline-container-org32bda16" class="outline-3">
<h3 id="org32bda16"><span class="section-number-3">4.6</span> Pitfall(s)</h3>
<div class="outline-text-3" id="text-4-6">
<p>
The use of <code>;</code> leads to some pitfalls for the beginner (and the guru not
paying enough attention).
</p>

<div class="org-src-container">
<pre class="src src-ocaml">(* This is syntactilly incorrect *)
let test_and_print =
  let count_success = ref 0 in
  fun secret -&gt;
  if secret = "you will never guess that" then
    incr count_success;
    Format.printf "Success"
  else Format.printf "Failure"
;;

(* This is *)
let test_and_print =
  let count_success = ref 0 in
  fun secret -&gt;
  if secret = "you will never guess that" then begin
      incr count_success;
      Format.printf "Success"
    end
  else Format.printf "Failure"
;;
</pre>
</div>
</div>
</div>

<div id="outline-container-org0bd10db" class="outline-3">
<h3 id="org0bd10db"><span class="section-number-3">4.7</span> Exceptions</h3>
<div class="outline-text-3" id="text-4-7">
<p>
Exceptions are open algebraic data types with a dedicated construct <code>exception</code>
</p>

<div class="org-src-container">
<pre class="src src-ocaml">exception Empty_list ;;

let nth i l =
  assert (i &gt;= 0);
  let rec aux j = function
    | [] -&gt;
       raise Empty_list
    | x :: xs -&gt;
       if j = 0 then x
       else aux (j - 1) xs
  in aux i l
;;
</pre>
</div>
</div>
</div>



<div id="outline-container-org8c5bc0c" class="outline-3">
<h3 id="org8c5bc0c"><span class="section-number-3">4.8</span> Local exceptions &amp; pattern-matching mixed exceptions/values</h3>
<div class="outline-text-3" id="text-4-8">
<div class="org-src-container">
<pre class="src src-ocaml">let find (type a) (p:a -&gt; bool) (arr:a array) =
  let exception Found of a in
  match Array.iter (fun e -&gt; if p e then raise (Found e)) arr with
  | () -&gt; None
  | exception (Found elt) -&gt; Some elt
;;
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-orgae57063" class="outline-2">
<h2 id="orgae57063"><span class="section-number-2">5</span> More advanced topics</h2>
<div class="outline-text-2" id="text-5">
</div>
<div id="outline-container-org78a746e" class="outline-3">
<h3 id="org78a746e"><span class="section-number-3">5.1</span> What's a module?</h3>
<div class="outline-text-3" id="text-5-1">
<p>
The moment you have 2 files, you will be manipulating <b>modules</b>.
</p>

<p>
A module is an abstraction barrier to used to bundle together related
definitions and functionalities. In particular, it defines a namespace.
</p>

<p>
A file defines a module: Both files <code>File</code> and <code>file</code> define module <code>File</code>
(thank you case-insensitive world).
</p>

<p>
Inside a module, one can define other modules.
</p>

<p>
Modules can be recursive.
</p>
</div>
</div>

<div id="outline-container-org7808c32" class="outline-3">
<h3 id="org7808c32"><span class="section-number-3">5.2</span> Interface &amp; implementation :: <code>mli</code> &amp; <code>ml</code></h3>
<div class="outline-text-3" id="text-5-2">
<p>
<code>OCaml</code> programmers are encouraged to detach API interface (documentation,
typing, &#x2026;) from their implementation.
</p>

<p>
The usage is to <b>not</b> type every and all functions coded, only the ones that
are exported and those whose type cannot be correctly inferred.
</p>

<p>
So for a given file-based module
</p>
<ul class="org-ul">
<li><code>mli</code> files contain interfaces (aka type signatures)</li>
<li><p>
<code>ml</code>  files contain implementations
</p>

<p>
For "programmatic" modules, you will use <code>module type</code> to abstract
functionalities/traits and <code>module</code> for implementing said modules.
</p></li>
</ul>
</div>

<div id="outline-container-org3d60083" class="outline-4">
<h4 id="org3d60083"><span class="section-number-4">5.2.1</span> Simple Functional Stacks</h4>
<div class="outline-text-4" id="text-5-2-1">
<p>
Let's have a look at the usual interface/implementation separation in
OCaml. We'll implement functional stacks to illustrate that.
</p>

<p>
Let's declare what a generic functional stack should offer in the <code>.mli</code>
file. This interface has been kept small.
</p>

<div class="org-src-container">
<pre class="src src-ocaml">(** {1 Functional stacks }*)

type 'a t

exception Empty

val empty : 'a t

val push : 'a -&gt; 'a t -&gt; 'a t

(** [pop s] raises an [Empty] exception if stack [s] is empty.
    [pop (push x l)] is the pair [(x, l)].
 *)
val pop : 'a t -&gt; 'a * 'a t

(** [pop (push x l)] is [Some (x, l)].
    [pop empty] is [None].
*)
val pop_opt : 'a t -&gt; ('a * 'a t) option

val is_empty : 'a t -&gt; bool

(** [fold f init s] where [s = push (a0 (push ... (push an empty)))]
    is  [f ... f (f init a0) a1 ... an ].
*)
val fold : f:('b -&gt; 'a -&gt; 'b) -&gt; 'b -&gt; 'a t -&gt; 'b
</pre>
</div>

<p>
Now, let's implement it. For the representation of stacks, we'll use OCaml
lists, with the head of the list as the top of the stack. The implementation
is rather straightforward. I chose to implement <code>pop_opt</code> w.r.t. to
<code>pop</code>. One could as well implement <code>pop</code> from <code>pop_opt</code>.
</p>

<div class="org-src-container">
<pre class="src src-ocaml">type 'a t = 'a list ;;

let empty = [] ;;

let push = List.cons ;;

exception Empty

let pop = function
  | [] -&gt; raise Empty
  | x :: xs -&gt; x, xs
;;

let pop_opt l =
  match pop l with
  | exception Empty -&gt; None
  | res -&gt; Some res
;;

let is_empty l = (=) [] l ;;

let fold ~f acc l = List.fold_left f acc l ;;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgf2f1401" class="outline-3">
<h3 id="orgf2f1401"><span class="section-number-3">5.3</span> Levels of type abstraction</h3>
<div class="outline-text-3" id="text-5-3">
<p>
Modules also delimit 'type abstraction'. One can choose among 3
level of abstraction.
</p>
</div>

<div id="outline-container-org45fe44f" class="outline-4">
<h4 id="org45fe44f"><span class="section-number-4">5.3.1</span> Open</h4>
<div class="outline-text-4" id="text-5-3-1">
<p>
Open types can be directly constructed &amp; destructed
</p>

<div class="org-src-container">
<pre class="src src-ocaml">module Interval = struct
  type t =
  | Ival of { lo : int; hi : int; }
  | Top
  ;;

  let top = Top ;;

  let ival ~lo ~hi =
    assert (lo &lt;= hi);
    if lo = min_int &amp;&amp; hi = max_int then top
    else Ival {lo; hi;}
  ;;

end
;;

open Interval

(* Pattern-matching is ok *)
let size = function
  | Ival {lo; hi; } -&gt; float @@ hi - lo + 1
  | Top -&gt; infinity
;;

(* This is authorized. *)
let interval = Top ;;

(* This is for the [top] function is part of the module signatures. *)
let top2 = top ;;
</pre>
</div>
</div>
</div>


<div id="outline-container-org80f25b4" class="outline-4">
<h4 id="org80f25b4"><span class="section-number-4">5.3.2</span> Private</h4>
<div class="outline-text-4" id="text-5-3-2">
<p>
Private types can be constructed only by predefined functions, destructed by
usual pattern matching.
</p>

<div class="org-src-container">
<pre class="src src-ocaml">module Interval : sig
  type t = private
    | Ival of { lo : int; hi: int;}
    | Top
  ;;

  val ival : lo:int -&gt; hi:int -&gt; t ;;
  val top : t
end = struct
  type t =
  | Ival of { lo : int; hi : int; }
  | Top
  ;;

  let top = Top ;;

  let ival ~lo ~hi =
    assert (lo &lt;= hi);
    if lo = min_int &amp;&amp; hi = max_int then top
    else Ival {lo; hi;}
  ;;

end
;;

open Interval

(* Pattern-matching is ok on private type *)
let size = function
  | Ival {lo; hi; } -&gt; float @@ hi - lo + 1
  | Top -&gt; infinity
;;

(* This is not authorized. *)
let interval = Top ;;

(* This is for the [top] function is part of the module signatures. *)
let top2 = top ;;
</pre>
</div>
</div>
</div>


<div id="outline-container-orgbae19ce" class="outline-4">
<h4 id="orgbae19ce"><span class="section-number-4">5.3.3</span> Abstract</h4>
<div class="outline-text-4" id="text-5-3-3">
<p>
Abstract types can be constructed &amp; destructed only be predefined functions
</p>

<div class="org-src-container">
<pre class="src src-ocaml">module Interval : sig
  type t (* opaque to the outside world *)
  val ival : lo:int -&gt; hi:int -&gt; t ;;
  val top : t

  val is_top : t -&gt; bool
  val lo : t -&gt; int (* raises an exception *)
  val hi : t -&gt; int
end = struct
  type t =
  | Ival of { lo : int; hi : int; }
  | Top
  ;;

  let top = Top ;;

  let ival ~lo ~hi =
    assert (lo &lt;= hi);
    if lo = min_int &amp;&amp; hi = max_int then top
    else Ival {lo; hi;}
  ;;

end
;;

open Interval

(* Pattern-matching does not work anymore *)
let size ival =
  if is_top ival then infinity
  else  hi ival - lo ival + 1
;;

(* This is still not authorized. *)
let interval = Top ;;

(* This is for the [top] function is part of the module signatures. *)
let top2 = top ;;
</pre>
</div>
</div>
</div>
</div>


<div id="outline-container-org382dc81" class="outline-3">
<h3 id="org382dc81"><span class="section-number-3">5.4</span> Genericity</h3>
<div class="outline-text-3" id="text-5-4">
</div>
<div id="outline-container-org94d83e7" class="outline-4">
<h4 id="org94d83e7"><span class="section-number-4">5.4.1</span> Ad-hoc polymorphism</h4>
<div class="outline-text-4" id="text-5-4-1">
<div class="org-src-container">
<pre class="src src-ocaml">let rec length match l with
  | [] -&gt; 0
  | _ :: l' -&gt; 1 + length l'
;;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcdabd2a" class="outline-4">
<h4 id="orgcdabd2a"><span class="section-number-4">5.4.2</span> Functors (module generator)</h4>
<div class="outline-text-4" id="text-5-4-2">
<p>
The standard library has functors for sets, maps (tree-based persistent
dictionaries) and hashtables.
</p>

<div class="org-src-container">
<pre class="src src-ocaml">module type PRINTABLE = sig
  type t
  val pp: Format.formatter -&gt; t -&gt; unit
end


module List_printer(X:PRINTABLE) = struct
  type printer_func = Format.formatter -&gt; unit -&gt; unit

  let pp_list
	?(pre=(fun ppf () -&gt; Format.pp_print_string ppf "["))
	?(post=(fun ppf () -&gt; Format.pp_print_string ppf "]"))
	?(sep=(fun ppf () -&gt; Format.fprintf ppf ";@ "))
	ppf l =
    let open Format in
    let rec loop = function
      | [] -&gt; post ppf ()
      | e :: es -&gt;
	 begin
	   X.pp ppf e;
	   sep ppf ();
	   loop es
	 end
    in pre ppf (); loop l
  ;;
end

module Int_list_pp =
  List_printer(struct type t = int let pp = Format.pp_print_int end)
;;

let pp = fun ppf l -&gt; Int_list_pp.pp_list ppf l in
pp Format.std_formatter [1;2;3] ;;

module String_list_pp =
  List_printer(struct type t = string let pp = Format.pp_print_string end)
;;

let pp_slist = fun ppf l -&gt; String_list_pp.pp_list ppf l;;
Format.printf "@[&lt;h&gt;%a@]" pp_slist  ["foo"; "bar"; "bar";] ;;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orga4023ab" class="outline-3">
<h3 id="orga4023ab"><span class="section-number-3">5.5</span> First-order modules</h3>
<div class="outline-text-3" id="text-5-5">
<p>
Modules can also be used as "first-class" values.
</p>

<div class="org-src-container">
<pre class="src src-ocaml">module type COMPARABLE = sig
  type t
  val compare : t -&gt; t -&gt; int
end
;;

let lmax (type a) (module M:COMPARABLE with type t = a) (l:a list) =
  let rec aux cur_max l =
    match l with
    | [] -&gt; cur_max
    | x :: xs -&gt;
       let cur_max' =
	 match cur_max with
	 | None -&gt; Some x
	 | Some vmax -&gt; if M.compare x vmax &gt; 0 then Some x else cur_max in
       aux cur_max' xs
  in aux None l
;;

module Int = struct
  type t = int ;;
  let compare = Pervasives.compare ;;
end
;;

lmax (module Int) [1;2;3;] ;;

(* Module [String] is part of the standard library *)
lmax (module String) ["foo"; "bar"; "baz";] ;;
</pre>
</div>
</div>

<div id="outline-container-org9eb8da7" class="outline-4">
<h4 id="org9eb8da7"><span class="section-number-4">5.5.1</span> More involved example</h4>
<div class="outline-text-4" id="text-5-5-1">
<div class="org-src-container">
<pre class="src src-ocaml">type ('var,'cst,'bop,'uop) expr =
  | Var of 'var
  | Cst of 'cst
  | Bop of 'bop * ('var,'cst,'bop,'uop) expr * ('var,'cst,'bop,'uop) expr
  | Uop of 'uop * ('var,'cst,'bop,'uop) expr
;;


module type EXPR = sig
  type var
  type uop
  type cst
  type bop
end

module Bool = struct
  type bop =
    | Band
    | Bor
    | Bxor
  ;;

  type uop = Bnot

  type var = string

  type cst = bool
end


let free_variables
      (type a b c d)
      (module M:EXPR with type var = a and
			  type cst = b and
			  type bop = c and
			  type uop = d)
      (e:(a,b,c,d) expr) : a list =
  let module S =
    Set.Make(struct type t = M.var let compare = Pervasives.compare end) in
  let rec loop (set:S.t) = function
    | Var v -&gt; S.add v set
    | Cst _ -&gt; set
    | Bop (_, e1, e2) -&gt; S.union (loop set e1) (loop S.empty e2)
    | Uop (_, e) -&gt; loop set e
  in
  let set = loop S.empty e in
  S.fold (fun e l -&gt; e :: l) set []
;;

free_variables (module Bool) (Var "foo") ;;

</pre>
</div>
</div>
</div>
</div>



<div id="outline-container-orgf3b675a" class="outline-3">
<h3 id="orgf3b675a"><span class="section-number-3">5.6</span> Monadic style programming</h3>
<div class="outline-text-3" id="text-5-6">
<p>
The following type has been making a comeback.
</p>

<div class="org-src-container">
<pre class="src src-ocaml">type ('a, 'b) result =
  | Ok of 'a
  | Error of 'b
;;
</pre>
</div>


<p>
and with it loads of heretofore banished monads :-)
</p>

<p>
There is no dedicated notation for working inside monads.
</p>

<p>
One usually uses the <code>M.bind</code> function of monad <code>M</code> or define an infix
operator. Here's a very contrived example.
</p>

<div class="org-src-container">
<pre class="src src-ocaml">let (&gt;&gt;=) = Option.bind ;;

let hd =
  | [] -&gt; None
  | x :: _ -&gt; Some x

let sum_heads l1 l2 =
  hd l1 &gt;&gt;=
    fun v1 -&gt; hd l2 &gt;&gt;=
    fun v2 -&gt; v1 + v2
;;
</pre>
</div>
</div>
</div>

<div id="outline-container-org9e0b911" class="outline-3">
<h3 id="org9e0b911"><span class="section-number-3">5.7</span> GADTs</h3>
<div class="outline-text-3" id="text-5-7">
<p>
Generalized Abstract Data Types are available in <code>OCaml</code> since version
<code>4.00</code>.
</p>

<p>
They are sparsely used
</p>

<div class="org-src-container">
<pre class="src src-ocaml">type arith_bop =
  | Add
  | Mul
  | Div
;;

type arith_uop =
  | UMin
;;

type comparison =
  | Eq
  | Gt
;;

type bool_bop =
  | Bor
  | Band
;;

type bool_uop =
  | Bnot
;;

type _ typ =
  | Int  : int -&gt; int typ
  | Bool : bool -&gt; bool typ
  | Ite  : bool typ * 'a typ * 'a typ -&gt; 'a typ
  | Bar  : arith_bop * int typ * int typ -&gt; int typ
  | Uar  : arith_uop * int typ -&gt; int typ
  | Cmp  : comparison * 'a typ * 'a typ -&gt; bool typ
  | Bbo  : bool_bop * bool typ * bool typ -&gt; bool typ
  | Ubo  : bool_uop * bool typ -&gt; bool typ
;;


let term = Ite ( Cmp (Eq, Int 3, Int 4), Int 12, Int 11) ;;

let term2 = Ite ( Cmp (Eq, Int 3, Int), Bool true, Bool false) ;;

let eval_abop = function
  | Add -&gt; ( + )
  | Mul -&gt; ( * )
  | Div -&gt; ( / )

let eval_cmp = function
  | Eq -&gt; ( = )
  | Gt -&gt; ( &gt; )

let eval_bbop = function
  | Bor -&gt; ( || )
  | Band -&gt; ( &amp;&amp; )

let rec eval: type a. a typ -&gt; a  = function
  | Int n -&gt; n
  | Bool b -&gt; b
  | Ite (b, ethen, eelse) -&gt; if eval b then eval ethen else eval eelse
  | Bar (op, e1, e2) -&gt; (eval_abop op) (eval e1) (eval e2)
  | Uar (UMin, e) -&gt; - (eval e)
  | Cmp (op, e1, e2) -&gt; (eval_cmp op) (eval e1) (eval e2)
  | Bbo (op, e1, e2) -&gt; (eval_bbop op) (eval e1) (eval e2)
  | Ubo (Bnot, e) -&gt; not (eval e)
;;

eval term ;;

eval term2 ;;
</pre>
</div>
</div>
</div>



<div id="outline-container-orgd2ac5bb" class="outline-3">
<h3 id="orgd2ac5bb"><span class="section-number-3">5.8</span> Death by GADTs</h3>
<div class="outline-text-3" id="text-5-8">
<p>
With great expressiveness comes great unreadability ;-)
</p>

<div class="org-src-container">
<pre class="src src-ocaml">(* in tdlib/camlinternalFormatBasics.ml *)
and ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,
     'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel =
  | Char_ty :                                                 (* %c  *)
      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,
       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel -&gt;
      (char -&gt; 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,
       char -&gt; 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel
  | String_ty :                                               (* %s  *)
      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,
       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel -&gt;
      (string -&gt; 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,
       string -&gt; 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel
  | Int_ty :                                                  (* %d  *)
      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,
       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel -&gt;
      (int -&gt; 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,
       int -&gt; 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel
  | Int32_ty :                                                (* %ld *)
      ('a1, 'b1, 'c1, 'd1, 'e1, 'f1,
       'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel -&gt;
      (int32 -&gt; 'a1, 'b1, 'c1, 'd1, 'e1, 'f1,
       int32 -&gt; 'a2, 'b2, 'c2, 'd2, 'e2, 'f2) fmtty_rel
</pre>
</div>

<div class="org-src-container">
<pre class="src src-ocaml">(* same file *)
let rec erase_rel : type a b c d e f g h i j k l .
  (a, b, c, d, e, f,
   g, h, i, j, k, l) fmtty_rel -&gt; (a, b, c, d, e, f) fmtty
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb082d27" class="outline-3">
<h3 id="orgb082d27"><span class="section-number-3">5.9</span> <code>Format</code>'ing text</h3>
<div class="outline-text-3" id="text-5-9">
<p>
The <code>Format</code> module is a nice <code>printf</code>-like pretty-printing facility
available in the standard library. This helps outputting structured data in a
good-looking way.
</p>

<p>
A <code>Format</code>-ted output mixes <b>boxes</b> and <b>break hints</b> to structure your output.
</p>

<p>
3 salient elements to think about
</p>
<ul class="org-ul">
<li><code>Format.fprintf</code></li>
<li>the formatter abstraction</li>
<li><code>%a</code> : chaining pretty printers</li>
</ul>


<div class="org-src-container">
<pre class="src src-ocaml">type t =
  | Int of int
  | Add of t * t
;;

open Format ;;

let rec pp_expr ppf = function
  | Int n -&gt; fprintf ppf "%i" n
  | Add (e1, e2) -&gt;
     fprintf ppf "@[%a@ +@ %a@]"
       pp_expression e1
       pp_expression e2

and pp_expression ppf =
  fprintf ppf "@[%a@]" pp_expr
;;


let rec addition_list = function
  | [] -&gt; assert false
  | [n] -&gt; Int n
  | x :: xs -&gt; Add (Int x, addition_list xs)
;;


let al =
  List.map (( + ) max_int) [1;2;3;4;5;6;7;]
  |&gt; addition_list
;;


Format.printf "%a@." pp_expr al;;
</pre>
</div>



<p>
For more:
</p>
<ul class="org-ul">
<li><a href="https://hal.archives-ouvertes.fr/hal-01503081/file/format-unraveled.pdf">https://hal.archives-ouvertes.fr/hal-01503081/file/format-unraveled.pdf</a></li>
</ul>
</div>
</div>


<div id="outline-container-org1b703cf" class="outline-3">
<h3 id="org1b703cf"><span class="section-number-3">5.10</span> Things that I did not talk about</h3>
<div class="outline-text-3" id="text-5-10">
<ul class="org-ul">
<li><p>
Polymorphic variants
</p>

<p>
See <a href="http://www.yakobowski.org/publis/2008/jfla08.pdf">http://www.yakobowski.org/publis/2008/jfla08.pdf</a> (in French)
</p></li>

<li><p>
Low-level representation
</p>

<p>
<a href="https://v1.realworldocaml.org/v1/en/html/memory-representation-of-values.html">https://v1.realworldocaml.org/v1/en/html/memory-representation-of-values.html</a>
</p></li>

<li>Objects</li>
<li>PPX syntax extensions (deriving, sexp, &#x2026;)</li>
<li>Ecosystem (parsing, JSONing, SMTing, &#x2026;)</li>
</ul>
</div>
</div>
</div>




<div id="outline-container-orgcca08a1" class="outline-2">
<h2 id="orgcca08a1"><span class="section-number-2">6</span> Conclusion</h2>
<div class="outline-text-2" id="text-6">
<p>
<code>OCaml</code> is <b>not</b> a language somehow stuck into a transformation to
<code>Haskell</code>.It follows different design choices, in the lineage of ML and SML.
</p>

<p>
Is there something that is missing ?
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 20200109</p>
<p class="author">Author: Richard B.</p>
<p class="date">Created: 2020-01-09 Thu 13:02</p>
<p class="validation"><a href="http://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
